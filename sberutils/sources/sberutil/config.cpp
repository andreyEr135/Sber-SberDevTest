#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <list>
#include <iterator>
#include <cstdio>

#include "debugsystem.h"
#include "config.h"

#undef  UNIT
#define UNIT  g_DebugSystem.units[ UNIT_CONFIG ]
#include "log_macros.def"

TConf::TConf()
{
    FUNCTION_TRACE
    m_lastError = 0;
}

TConf::~TConf()
{
    FUNCTION_TRACE
    m_groups.clear();
    m_params.clear();
}

int TConf::LoadFile(const char* fileName)
{
    FUNCTION_TRACE
    m_lastError = 0;

    std::ifstream fileStream;
    std::string currentLine;
    int autoGeneratedIndex = 0;

    fileStream.open(fileName, std::ios::in);
    if (!fileStream.is_open())
    {
        m_lastError = -1;
        errno = 0;
        return m_lastError;
    }

    while (std::getline(fileStream, currentLine))
    {
        std::string::size_type commentPos;
        // Удаляем комментарии, начинающиеся с '#'
        if ((commentPos = currentLine.find('#')) != std::string::npos)
            currentLine.erase(commentPos);

        currentLine = trim(currentLine);
        if (currentLine.empty()) continue;

        // Обработка заголовка группы [GroupName]
        if (currentLine.front() == '[' && currentLine.back() == ']')
        {
            currentLine.erase(0, 1);
            currentLine.erase(currentLine.length() - 1, 1);
            currentLine = trim(currentLine);

            if (currentLine.empty()) continue;

            m_groups.push_back(currentLine);
            autoGeneratedIndex = 0;
        }
        else // Обработка параметра name = value
        {
            std::string paramName;
            std::string paramValue;
            std::string::size_type delimiterPos = currentLine.find('=');

            if (delimiterPos != std::string::npos)
            {
                paramName = currentLine.substr(0, delimiterPos);
                paramValue = currentLine.substr(delimiterPos + 1);
            }
            else
            {
                // Если '=' нет, используем порядковый номер как имя
                char indexString[16];
                sprintf(indexString, "%d", autoGeneratedIndex);
                paramName = indexString;
                paramValue = currentLine;
                autoGeneratedIndex++;
            }

            paramName = trim(paramName);
            paramValue = trim(paramValue);

            // Очистка от кавычек
            if (paramValue.size() >= 2)
            {
                if ((paramValue.front() == '\'' && paramValue.back() == '\'') ||
                    (paramValue.front() == '\"' && paramValue.back() == '\"'))
                {
                    paramValue = paramValue.substr(1, paramValue.size() - 2);
                }
            }

            // Если группа не была определена, создаем пустую "дефолтную"
            if (m_groups.empty()) m_groups.push_back("");

            TParam newParam = { &m_groups.back(), paramName, paramValue };
            m_params.push_back(newParam);
        }
    }
    fileStream.close();

    return m_lastError;
}

int TConf::LoadFile(const std::string& fileName)
{
    return LoadFile(fileName.c_str());
}

const std::string TConf::GetParamNameById(const std::string& groupName, int paramId)
{
    FUNCTION_TRACE
    m_lastError = 0;
    int currentMatchIndex = 0;

    for (const auto& parameter : m_params)
    {
        if (groupName == *(parameter.group))
        {
            if (currentMatchIndex++ == paramId) return parameter.name;
        }
    }
    m_lastError = -2;
    return "";
}

const std::string TConf::ReadString(const std::string& groupName, const std::string& paramName)
{
    FUNCTION_TRACE
    m_lastError = 0;
    for (const auto& parameter : m_params)
    {
        if (groupName == *(parameter.group) && paramName == parameter.name)
            return parameter.value;
    }
    m_lastError = -2;
    return "";
}

const int TConf::ReadInt(const std::string& groupName, const std::string& paramName)
{
    FUNCTION_TRACE
    std::string valueStr = ReadString(groupName, paramName);
    int numericValue = 0;
    if (!valueStr.empty())
    {
        sscanf(valueStr.c_str(), "%d", &numericValue);
    }
    return numericValue;
}

const int TConf::ReadHex(const std::string& groupName, const std::string& paramName)
{
    FUNCTION_TRACE
    std::string valueStr = ReadString(groupName, paramName);
    int hexValue = 0;
    if (!valueStr.empty())
    {
        sscanf(valueStr.c_str(), "%X", &hexValue);
    }
    return hexValue;
}

const float TConf::ReadFloat(const std::string& groupName, const std::string& paramName)
{
    FUNCTION_TRACE
    return str2float(ReadString(groupName, paramName));
}

void TConf::PrintAll()
{
    FUNCTION_TRACE
    for (const auto& parameter : m_params)
    {
        std::cout << '[' << *(parameter.group) << "] "
                  << parameter.name << " = " << parameter.value << std::endl;
    }
}

const char* TConf::GetLastErrorStr()
{
    switch (m_lastError)
    {
        case  0: return "OK";
        case -1: return "error open file";
        case -2: return "not found";
        default: return "unknown error";
    }
}
